<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>尺规作图工具（已修复吸附/交点）</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: Arial, sans-serif;
            background-color: #f5f5f5;
            color: #333;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        .header {
            background-color: #fff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .header h1 {
            font-size: 24px;
            color: #2c3e50;
        }
        .header-controls {
            display: flex;
            gap: 10px;
        }
        .header-controls button {
            padding: 8px 16px;
            background-color: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }
        .header-controls button:hover {
            background-color: #2980b9;
        }
        .main-content {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
        }
        .toolbar {
            background-color: #fff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            min-width: 200px;
        }
        .toolbar h3 {
            margin-bottom: 15px;
            color: #2c3e50;
        }
        .tool-btn {
            display: block;
            width: 100%;
            padding: 10px;
            margin-bottom: 8px;
            background-color: #ecf0f1;
            border: 1px solid #bdc3c7;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            text-align: left;
        }
        .tool-btn:hover {
            background-color: #d5dbdb;
        }
        .tool-btn.active {
            background-color: #3498db;
            color: white;
            border-color: #3498db;
        }
        .canvas-container {
            flex: 1;
            background-color: #fff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            position: relative;
        }
        #canvas {
            border: 1px solid #ddd;
            background-color: #fafafa;
            cursor: crosshair;
        }
        .footer {
            background-color: #fff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            text-align: center;
        }
        .footer p {
            font-size: 14px;
            color: #7f8c8d;
        }
    </style>
</head>
<body>
<div class="container">
    <header class="header">
        <h1>尺规作图工具（吸附/交点已修复）</h1>
        <div class="header-controls">
            <button id="undo-btn">撤销</button>
            <button id="redo-btn">反撤销</button>
            <button id="clear-btn">清空画布</button>
            <button id="save-btn">保存PNG</button>
        </div>
    </header>
    <div class="main-content">
        <div class="toolbar">
                <h3>工具</h3>
                <button class="tool-btn active" data-tool="select">选择</button>
                <button class="tool-btn" data-tool="point">点</button>
                <button class="tool-btn" data-tool="segment">线段</button>
                <button class="tool-btn" data-tool="line">直线</button>
                <button class="tool-btn" data-tool="circle">圆</button>
                <button class="tool-btn" data-tool="intersection">交点</button>
            </div>
        <div class="canvas-container">
            <canvas id="canvas" width="900" height="600"></canvas>
        </div>
    </div>
    <footer class="footer">
        <p>鼠标靠近点/线/圆会自动吸附 | 交点工具：依次点击两个图形</p>
    </footer>
</div>

<script>
class Point {
    constructor(x, y, id) {
        this.x = x;
        this.y = y;
        this.id = id || `p_${Date.now()}_${Math.random().toString(36).slice(2,9)}`;
        this.selected = false;
    }
    draw(ctx) {
        ctx.beginPath();
        ctx.arc(this.x, this.y, 4, 0, Math.PI*2);
        ctx.fillStyle = this.selected ? '#e74c3c' : '#2c3e50';
        ctx.fill();
        ctx.strokeStyle = this.selected ? '#e74c3c' : '#2c3e50';
        ctx.lineWidth = 2;
        ctx.stroke();
    }
    distanceTo(p) {
        return Math.hypot(this.x-p.x, this.y-p.y);
    }
    move(dx, dy) {
        this.x += dx;
        this.y += dy;
    }
    isNear(x, y, tol=6) {
        return this.distanceTo({x,y}) < tol;
    }
}

class Line {
    constructor(p1, p2, type='segment', id) {
        this.p1 = p1;
        this.p2 = p2;
        this.type = type;
        this.id = id || `l_${Date.now()}_${Math.random().toString(36).slice(2,9)}`;
        this.selected = false;
    }
    draw(ctx) {
        ctx.beginPath();
        if (this.type === 'segment') {
            ctx.moveTo(this.p1.x, this.p1.y);
            ctx.lineTo(this.p2.x, this.p2.y);
        } else {
            const dx = this.p2.x - this.p1.x;
            const dy = this.p2.y - this.p1.y;
            const len = Math.hypot(dx, dy);
            const ux = dx/len, uy = dy/len;
            ctx.moveTo(this.p1.x - ux*2000, this.p1.y - uy*2000);
            ctx.lineTo(this.p1.x + ux*2000, this.p1.y + uy*2000);
        }
        ctx.strokeStyle = this.selected ? '#e74c3c' : '#2c3e50';
        ctx.lineWidth = this.selected ? 3 : 2;
        ctx.stroke();
    }
}

class Circle {
    constructor(center, radius, id) {
        this.center = center;
        this.radius = radius;
        this.id = id || `c_${Date.now()}_${Math.random().toString(36).slice(2,9)}`;
        this.selected = false;
    }
    draw(ctx) {
        ctx.beginPath();
        ctx.arc(this.center.x, this.center.y, this.radius, 0, Math.PI*2);
        ctx.strokeStyle = this.selected ? '#e74c3c' : '#2c3e50';
        ctx.lineWidth = this.selected ? 3 : 2;
        ctx.stroke();
    }
}

class GeometryCanvas {
    constructor(canvasId) {
        this.cvs = document.getElementById(canvasId);
        this.ctx = this.cvs.getContext('2d');
        this.elements = [];
        this.tool = 'select';
        this.selected = [];
        this.temp = null;
        this.stack = [];
        this.redoStack = [];
        this.snapTol = 20;
        this.snapPoint = null;
        this.hoverPoint = null;
        this.init();
    }

    init() {
        this.bindEvents();
        this.save();
        this.render();
    }

    save() {
        const state = this.elements.map(e => {
            if (e instanceof Point) {
                return {
                    type: 'Point',
                    x: e.x,
                    y: e.y,
                    id: e.id
                };
            } else if (e instanceof Line) {
                return {
                    type: 'Line',
                    p1id: e.p1.id,
                    p2id: e.p2.id,
                    lineType: e.type,
                    id: e.id
                };
            } else if (e instanceof Circle) {
                return {
                    type: 'Circle',
                    centerid: e.center.id,
                    radius: e.radius,
                    id: e.id
                };
            }
            return null;
        }).filter(Boolean);
        
        this.stack.push(JSON.parse(JSON.stringify(state)));
        this.redoStack = [];
        if (this.stack.length > 30) {
            this.stack.shift();
        }
    }

    undo() {
        if (this.stack.length < 2) return;
        this.redoStack.push(this.stack.pop());
        this.loadState(this.stack[this.stack.length - 1]);
    }

    redo() {
        if (this.redoStack.length === 0) return;
        const state = this.redoStack.pop();
        this.stack.push(state);
        this.loadState(state);
    }

    loadState(state) {
        const pointsMap = new Map();
        this.elements = [];
        
        // 先创建所有点
        state.forEach(item => {
            if (item.type === 'Point') {
                const point = new Point(item.x, item.y, item.id);
                pointsMap.set(point.id, point);
                this.elements.push(point);
            }
        });
        
        // 再创建线和圆
        state.forEach(item => {
            if (item.type === 'Line') {
                const p1 = pointsMap.get(item.p1id);
                const p2 = pointsMap.get(item.p2id);
                if (p1 && p2) {
                    const line = new Line(p1, p2, item.lineType || 'segment', item.id);
                    this.elements.push(line);
                }
            } else if (item.type === 'Circle') {
                const center = pointsMap.get(item.centerid);
                if (center) {
                    const circle = new Circle(center, item.radius, item.id);
                    this.elements.push(circle);
                }
            }
        });
        
        this.render();
    }

    getMouse(e) {
        const r = this.cvs.getBoundingClientRect();
        return {
            x: e.clientX - r.left,
            y: e.clientY - r.top
        };
    }

    getSnapPoint(x, y) {
        let best = null;
        let minDist = this.snapTol;
        const mp = new Point(x,y);
        this.elements.forEach(e => {
            if (e instanceof Point) {
                const d = e.distanceTo(mp);
                if (d < minDist) { minDist = d; best = e; }
            }
            if (e instanceof Line) {
                const proj = this.projectOnLine(mp, e);
                const d = mp.distanceTo(proj);
                if (d < minDist) { minDist = d; best = proj; }
            }
            if (e instanceof Circle) {
                const d = Math.abs(mp.distanceTo(e.center) - e.radius);
                if (d < minDist) {
                    minDist = d;
                    const angle = Math.atan2(mp.y-e.center.y, mp.x-e.center.x);
                    best = new Point(
                        e.center.x + e.radius*Math.cos(angle),
                        e.center.y + e.radius*Math.sin(angle)
                    );
                }
            }
        });
        return best;
    }

    projectOnLine(p, line) {
        const A = line.p1, B = line.p2;
        const ax = p.x-A.x, ay = p.y-A.y;
        const bx = B.x-A.x, by = B.y-A.y;
        const t = Math.max(0, Math.min(1, (ax*bx + ay*by)/(bx*bx+by*by)));
        return new Point(A.x + t*bx, A.y + t*by);
    }

    getElementAt(x,y) {
        for(let i=this.elements.length-1; i>=0; i--){
            const e = this.elements[i];
            if (e instanceof Point && e.isNear(x,y)) return e;
            if (e instanceof Line) {
                const proj = this.projectOnLine(new Point(x,y),e);
                if (proj.distanceTo({x,y}) < 6) return e;
            }
            if (e instanceof Circle) {
                const d = Math.hypot(x-e.center.x, y-e.center.y);
                if (Math.abs(d - e.radius) < 6) return e;
            }
        }
        return null;
    }

    bindEvents() {
        this.cvs.addEventListener('mousedown', e=>{
            if (e.button!==0) return;
            const m = this.getMouse(e);
            this.snapPoint = this.getSnapPoint(m.x, m.y);
            const sx = this.snapPoint?.x ?? m.x;
            const sy = this.snapPoint?.y ?? m.y;
            const elem = this.getElementAt(sx, sy);

            switch(this.tool){
                case 'point':
                    this.elements.push(new Point(sx,sy));
                    this.save();
                    break;
                case 'segment':
                case 'line':
                    if (!this.temp) {
                        const p = new Point(sx,sy);
                        this.elements.push(p);
                        this.temp = {p1:p, p2:new Point(sx,sy), type:this.tool};
                    } else {
                        const p2 = new Point(sx,sy);
                        this.elements.push(p2);
                        this.elements.push(new Line(this.temp.p1,p2,this.tool));
                        this.temp = null;
                        this.save();
                    }
                    break;
                case 'circle':
                    if (!this.temp) {
                        const c = new Point(sx,sy);
                        this.elements.push(c);
                        this.temp = {center:c, r:0};
                    } else {
                        const r = this.temp.center.distanceTo({x:sx,y:sy});
                        this.elements.push(new Circle(this.temp.center, r));
                        this.temp = null;
                        this.save();
                    }
                    break;
                case 'intersection':
                    if (!this.temp) this.temp = {a:null,b:null};
                    if (!this.temp.a) this.temp.a = elem;
                    else if (!this.temp.b) {
                        this.temp.b = elem;
                        this.computeIntersection(this.temp.a, this.temp.b);
                        this.temp = null;
                    }
                    break;

            }
            this.render();
        });

        this.cvs.addEventListener('mousemove', e=>{
            const m = this.getMouse(e);
            this.snapPoint = this.getSnapPoint(m.x, m.y);
            const sx = this.snapPoint?.x ?? m.x;
            const sy = this.snapPoint?.y ?? m.y;

            if (this.temp) {
                if (this.temp.p2) {
                    this.temp.p2.x = sx;
                    this.temp.p2.y = sy;
                }
                if (this.temp.center) {
                    this.temp.r = this.temp.center.distanceTo({x:sx,y:sy});
                }
            }
            this.render();
        });

        this.cvs.addEventListener('mouseup', ()=>{
        });

        document.querySelectorAll('.tool-btn').forEach(b=>{
            b.onclick = ()=>{
                document.querySelectorAll('.tool-btn').forEach(x=>x.classList.remove('active'));
                b.classList.add('active');
                this.tool = b.dataset.tool;
                this.temp = null;
                this.selected = [];
                this.render();
            }
        });

        document.getElementById('undo-btn').onclick = ()=>this.undo();
        document.getElementById('redo-btn').onclick = ()=>this.redo();
        document.getElementById('clear-btn').onclick = ()=>{
            if(confirm('清空？')){
                this.elements = [];
                this.temp = null;
                this.save();
                this.render();
            }
        };
        document.getElementById('save-btn').onclick = ()=>{
            const a = document.createElement('a');
            a.download = '尺规作图_'+Date.now()+'.png';
            a.href = this.cvs.toDataURL('image/png');
            a.click();
        };

        document.addEventListener('keydown', e=>{
            if(e.ctrlKey && e.key==='z'){ e.preventDefault(); this.undo(); }
            if(e.ctrlKey && e.key==='y'){ e.preventDefault(); this.redo(); }
        });
    }

    computeIntersection(a,b) {
        let pts = [];
        if (a instanceof Line && b instanceof Line) pts = this.lineLine(a,b);
        if (a instanceof Line && b instanceof Circle) pts = this.lineCircle(a,b);
        if (a instanceof Circle && b instanceof Line) pts = this.lineCircle(b,a);
        if (a instanceof Circle && b instanceof Circle) pts = this.circleCircle(a,b);
        pts.forEach(p=>{
            if (!this.elements.some(e=>e instanceof Point && e.distanceTo(p)<3)) {
                this.elements.push(new Point(p.x,p.y));
            }
        });
        this.save();
        this.render();
    }

    lineLine(l1,l2) {
        const A=l1.p1,B=l1.p2,C=l2.p1,D=l2.p2;
        const den = (B.x-A.x)*(D.y-C.y) - (B.y-A.y)*(D.x-C.x);
        if (Math.abs(den)<1e-6) return [];
        const t = ((C.x-A.x)*(D.y-C.y) - (C.y-A.y)*(D.x-C.x))/den;
        const x = A.x + t*(B.x-A.x);
        const y = A.y + t*(B.y-A.y);
        return [new Point(x,y)];
    }

    lineCircle(l,c) {
        const A=l.p1,B=l.p2,O=c.center,r=c.radius;
        const ax=A.x-O.x, ay=A.y-O.y;
        const bx=B.x-A.x, by=B.y-A.y;
        const a=bx*bx+by*by;
        const b=2*(ax*bx+ay*by);
        const cc=ax*ax+ay*ay-r*r;
        const D=b*b-4*a*cc;
        if (D<0) return [];
        const t1=(-b-Math.sqrt(D))/(2*a);
        const t2=(-b+Math.sqrt(D))/(2*a);
        return [
            new Point(A.x+t1*bx, A.y+t1*by),
            new Point(A.x+t2*bx, A.y+t2*by)
        ];
    }

    circleCircle(c1,c2) {
        const O1=c1.center,O2=c2.center,r1=c1.radius,r2=c2.radius;
        const dx=O2.x-O1.x, dy=O2.y-O1.y;
        const d=Math.hypot(dx,dy);
        if (d>r1+r2 || d<Math.abs(r1-r2) || d<1e-6) return [];
        const a=(r1*r1 - r2*r2 + d*d)/(2*d);
        const h=Math.sqrt(r1*r1 - a*a);
        const xm=O1.x + a*dx/d;
        const ym=O1.y + a*dy/d;
        const rx=-dy*h/d, ry=dx*h/d;
        return [
            new Point(xm+rx, ym+ry),
            new Point(xm-rx, ym-ry)
        ];
    }

    render() {
        this.ctx.clearRect(0,0,this.cvs.width,this.cvs.height);
        this.elements.forEach(e=>e.draw(this.ctx));
        if (this.snapPoint) {
            this.ctx.beginPath();
            this.ctx.arc(this.snapPoint.x,this.snapPoint.y,8,0,Math.PI*2);
            this.ctx.strokeStyle='#3498db';
            this.ctx.lineWidth=2;
            this.ctx.setLineDash([3,3]);
            this.ctx.stroke();
            this.ctx.setLineDash([]);
        }
        if (this.temp) {
            this.ctx.strokeStyle='#95a5a6';
            this.ctx.lineWidth=2;
            if (this.temp.p1 && this.temp.p2) {
                this.ctx.beginPath();
                this.ctx.moveTo(this.temp.p1.x,this.temp.p1.y);
                this.ctx.lineTo(this.temp.p2.x,this.temp.p2.y);
                this.ctx.stroke();
            }
            if (this.temp.center && this.temp.r>0) {
                this.ctx.beginPath();
                this.ctx.arc(this.temp.center.x,this.temp.center.y,this.temp.r,0,Math.PI*2);
                this.ctx.stroke();
            }
        }
    }
}

window.addEventListener('DOMContentLoaded', () => {
    new GeometryCanvas('canvas');
});
</script>
</body>
</html>