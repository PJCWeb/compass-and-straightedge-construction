<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸ¯ çœŸÂ·å¸é™„å°ºè§„ Â· åªå¸ç‚¹ä¸å¸ç©ºæ°”</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Segoe UI', Roboto, Arial, sans-serif;
            background-color: #1a1e24;
            color: #e0e0e0;
        }
        .container {
            max-width: 1280px;
            margin: 0 auto;
            padding: 20px;
        }
        .header {
            background-color: #252b33;
            padding: 16px 24px;
            border-radius: 16px;
            box-shadow: 0 6px 12px rgba(0,0,0,0.2);
            margin-bottom: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            border: 1px solid #3a4350;
        }
        .header h1 {
            font-size: 1.8rem;
            font-weight: 600;
            color: #ffd966;
            letter-spacing: 0.5px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        .header-controls {
            display: flex;
            gap: 10px;
        }
        .header-controls button {
            padding: 8px 18px;
            background-color: #3a4a5c;
            color: white;
            border: none;
            border-radius: 40px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 500;
            transition: all 0.2s;
            border: 1px solid #4f637a;
        }
        .header-controls button:hover {
            background-color: #4f637a;
            transform: translateY(-1px);
        }
        .main-content {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
        }
        .toolbar {
            background-color: #252b33;
            padding: 20px 12px;
            border-radius: 16px;
            box-shadow: 0 6px 12px rgba(0,0,0,0.2);
            min-width: 170px;
            border: 1px solid #3a4350;
        }
        .toolbar h3 {
            margin-bottom: 16px;
            color: #ffd966;
            font-weight: 600;
            font-size: 1.2rem;
            padding-left: 8px;
        }
        .tool-btn {
            display: block;
            width: 100%;
            padding: 10px 14px;
            margin-bottom: 8px;
            background-color: #2e3740;
            border: 1px solid #44515f;
            border-radius: 30px;
            cursor: pointer;
            font-size: 0.95rem;
            text-align: left;
            font-weight: 500;
            color: #d0d9e5;
            transition: all 0.1s;
        }
        .tool-btn:hover {
            background-color: #3f4b58;
            border-color: #ffd966;
            color: white;
        }
        .tool-btn.active {
            background-color: #ffd966;
            color: #1a1e24;
            border-color: #ffd966;
            font-weight: 600;
        }
        .canvas-container {
            flex: 1;
            background-color: #252b33;
            padding: 16px;
            border-radius: 16px;
            box-shadow: 0 6px 12px rgba(0,0,0,0.2);
            display: flex;
            justify-content: center;
            border: 1px solid #3a4350;
        }
        #canvas {
            border: 1px solid #44515f;
            background-color: #1e242b;
            cursor: crosshair;
            border-radius: 12px;
            width: 100%;
            height: auto;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.4);
        }
        .footer {
            background-color: #252b33;
            padding: 14px 24px;
            border-radius: 40px;
            box-shadow: 0 6px 12px rgba(0,0,0,0.2);
            display: flex;
            justify-content: space-between;
            align-items: center;
            border: 1px solid #3a4350;
        }
        .status-bar {
            padding: 6px 18px;
            background-color: #1e242b;
            border-radius: 30px;
            font-size: 0.95rem;
            font-weight: 500;
            color: #ffd966;
            border: 1px solid #44515f;
            font-family: monospace;
        }
        .legend {
            display: flex;
            gap: 20px;
            color: #a0b0c0;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background-color: #ffd966;
            box-shadow: 0 0 8px #ffd966;
        }
    </style>
</head>
<body>
<div class="container">
    <header class="header">
        <h1>ğŸ¯ çœŸÂ·å¸é™„å°ºè§„ Â· åªå¸ç‚¹ä¸å¸ç©ºæ°”</h1>
        <div class="header-controls">
            <button id="undo-btn">â†© æ’¤é”€</button>
            <button id="redo-btn">â†ª é‡åš</button>
            <button id="clear-btn">ğŸ—‘ æ¸…ç©º</button>
            <button id="save-btn">ğŸ’¾ ä¿å­˜PNG</button>
        </div>
    </header>
    <div class="main-content">
        <div class="toolbar">
            <h3>âš’ï¸ å·¥å…·</h3>
            <button class="tool-btn active" data-tool="select">ğŸ” é€‰æ‹©</button>
            <button class="tool-btn" data-tool="point">âš« ç‚¹</button>
            <button class="tool-btn" data-tool="segment">ğŸ“ çº¿æ®µ</button>
            <button class="tool-btn" data-tool="line">ğŸ“ˆ ç›´çº¿</button>
            <button class="tool-btn" data-tool="circle">â­• åœ†</button>
            <button class="tool-btn" data-tool="intersection">âœ– äº¤ç‚¹</button>
        </div>
        <div class="canvas-container">
            <canvas id="canvas" width="950" height="600"></canvas>
        </div>
    </div>
    <footer class="footer">
        <div class="legend">
            <span class="legend-item"><span class="dot"></span> é»„é‡‘å¸é™„åœˆ Â· åªå¸å·²æœ‰çš„ç‚¹</span>
        </div>
        <div id="status" class="status-bar">ğŸ‘‰ é€‰å·¥å…·å¼€å§‹</div>
    </footer>
</div>

<script>
(function() {
    const statusEl = document.getElementById('status');
    
    // å·¥å…·åç§°
    const toolNames = {
        'select': 'é€‰æ‹©',
        'point': 'ç‚¹',
        'segment': 'çº¿æ®µ',
        'line': 'ç›´çº¿',
        'circle': 'åœ†',
        'intersection': 'äº¤ç‚¹'
    };

    class Point {
        constructor(x, y, id) {
            this.x = x;
            this.y = y;
            this.id = id || `p_${Date.now()}_${Math.random().toString(36).slice(2,9)}`;
            this.selected = false;
        }
        draw(ctx) {
            ctx.beginPath();
            ctx.arc(this.x, this.y, 5, 0, 2*Math.PI);
            ctx.fillStyle = this.selected ? '#ff8a7a' : '#ffd966';
            ctx.fill();
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 1.5;
            ctx.stroke();
            
            // å‘å…‰æ•ˆæœ
            ctx.shadowColor = '#ffd966';
            ctx.shadowBlur = 8;
            ctx.fill();
            ctx.shadowBlur = 0;
        }
        distanceTo(p) {
            return Math.hypot(this.x - p.x, this.y - p.y);
        }
        isNear(x, y, tol = 8) {
            return this.distanceTo({x, y}) < tol;
        }
    }

    class Line {
        constructor(p1, p2, type = 'segment', id) {
            this.p1 = p1;
            this.p2 = p2;
            this.type = type;
            this.id = id || `l_${Date.now()}_${Math.random().toString(36).slice(2,9)}`;
            this.selected = false;
        }
        draw(ctx) {
            ctx.beginPath();
            if (this.type === 'segment') {
                ctx.moveTo(this.p1.x, this.p1.y);
                ctx.lineTo(this.p2.x, this.p2.y);
            } else {
                const dx = this.p2.x - this.p1.x;
                const dy = this.p2.y - this.p1.y;
                const len = Math.hypot(dx, dy);
                if (len < 1e-9) return;
                const ux = dx / len;
                const uy = dy / len;
                ctx.moveTo(this.p1.x - ux * 3000, this.p1.y - uy * 3000);
                ctx.lineTo(this.p1.x + ux * 3000, this.p1.y + uy * 3000);
            }
            ctx.strokeStyle = this.selected ? '#ff8a7a' : '#7a8b9f';
            ctx.lineWidth = this.selected ? 3.5 : 2.2;
            ctx.stroke();
        }
    }

    class Circle {
        constructor(center, radius, id) {
            this.center = center;
            this.radius = radius;
            this.id = id || `c_${Date.now()}_${Math.random().toString(36).slice(2,9)}`;
            this.selected = false;
        }
        draw(ctx) {
            ctx.beginPath();
            ctx.arc(this.center.x, this.center.y, this.radius, 0, 2*Math.PI);
            ctx.strokeStyle = this.selected ? '#ff8a7a' : '#7a8b9f';
            ctx.lineWidth = this.selected ? 3.5 : 2.2;
            ctx.stroke();
        }
    }

    // ========== æ ¸å¿ƒï¼šçœŸæ­£çš„ç‚¹å¸é™„ ==========
    class GeometryCanvas {
        constructor(canvasId) {
            this.cvs = document.getElementById(canvasId);
            this.ctx = this.cvs.getContext('2d');
            this.elements = [];
            this.tool = 'select';
            this.temp = null;
            this.stack = [];
            this.redoStack = [];

            // å¸é™„åªé’ˆå¯¹å·²æœ‰çš„ç‚¹
            this.snapTol = 15;        // å¸é™„è·ç¦»
            this.snapPoint = null;     // å½“å‰å¸é™„åˆ°çš„ç‚¹ï¼ˆåªæœ‰çœŸæ­£çš„ç‚¹ï¼‰
            
            this.intersectCache = { a: null, b: null };

            this.init();
        }

        init() {
            this.bindEvents();
            this.saveInitialState();
            this.render();
            this.updateStatus('ğŸ‘† é€‰æ‹©å·¥å…·');
        }

        updateStatus(msg) {
            statusEl.textContent = `ğŸ‘‰ ${msg}`;
        }

        saveState() {
            const state = this.elements.map(el => {
                if (el instanceof Point) {
                    return { type: 'Point', x: el.x, y: el.y, id: el.id };
                } else if (el instanceof Line) {
                    return {
                        type: 'Line',
                        p1id: el.p1.id,
                        p2id: el.p2.id,
                        lineType: el.type,
                        id: el.id
                    };
                } else if (el instanceof Circle) {
                    return { type: 'Circle', centerid: el.center.id, radius: el.radius, id: el.id };
                }
                return null;
            }).filter(Boolean);
            this.stack.push(JSON.parse(JSON.stringify(state)));
            this.redoStack = [];
            if (this.stack.length > 40) this.stack.shift();
        }

        saveInitialState() {
            this.saveState();
        }

        undo() {
            if (this.stack.length < 2) return;
            this.redoStack.push(this.stack.pop());
            this.loadState(this.stack[this.stack.length - 1]);
            this.updateStatus('æ’¤é”€');
        }

        redo() {
            if (this.redoStack.length === 0) return;
            const state = this.redoStack.pop();
            this.stack.push(state);
            this.loadState(state);
            this.updateStatus('é‡åš');
        }

        loadState(state) {
            const pointMap = new Map();
            this.elements = [];

            state.forEach(item => {
                if (item.type === 'Point') {
                    const p = new Point(item.x, item.y, item.id);
                    pointMap.set(p.id, p);
                    this.elements.push(p);
                }
            });
            state.forEach(item => {
                if (item.type === 'Line') {
                    const p1 = pointMap.get(item.p1id);
                    const p2 = pointMap.get(item.p2id);
                    if (p1 && p2) {
                        this.elements.push(new Line(p1, p2, item.lineType, item.id));
                    }
                } else if (item.type === 'Circle') {
                    const center = pointMap.get(item.centerid);
                    if (center) {
                        this.elements.push(new Circle(center, item.radius, item.id));
                    }
                }
            });
            this.temp = null;
            this.intersectCache = { a: null, b: null };
            this.render();
        }

        getMouse(e) {
            const rect = this.cvs.getBoundingClientRect();
            const scaleX = this.cvs.width / rect.width;
            const scaleY = this.cvs.height / rect.height;
            return {
                x: (e.clientX - rect.left) * scaleX,
                y: (e.clientY - rect.top) * scaleY
            };
        }

        // ========== åªå¸é™„çœŸæ­£çš„ç‚¹ ==========
        getSnapPoint(x, y) {
            let bestDist = this.snapTol;
            let bestPoint = null;

            for (let el of this.elements) {
                if (el instanceof Point) {
                    const d = Math.hypot(el.x - x, el.y - y);
                    if (d < bestDist) {
                        bestDist = d;
                        bestPoint = el;      // åªè¿”å›çœŸæ­£çš„ç‚¹å¯¹è±¡
                    }
                }
            }
            return bestPoint;
        }

        // è·å–é¼ æ ‡ä¸‹çš„å®ä½“
        getElementUnderMouse(x, y) {
            for (let i = this.elements.length - 1; i >= 0; i--) {
                const el = this.elements[i];
                if (el instanceof Point && el.isNear(x, y, 8)) return el;
                if (el instanceof Line) {
                    const A = el.p1, B = el.p2;
                    const ax = x - A.x, ay = y - A.y;
                    const bx = B.x - A.x, by = B.y - A.y;
                    const len2 = bx * bx + by * by;
                    if (len2 < 1e-12) continue;
                    let t = (ax * bx + ay * by) / len2;
                    if (el.type === 'segment') t = Math.max(0, Math.min(1, t));
                    const projX = A.x + t * bx;
                    const projY = A.y + t * by;
                    if (Math.hypot(projX - x, projY - y) < 8) return el;
                }
                if (el instanceof Circle) {
                    const d = Math.hypot(x - el.center.x, y - el.center.y);
                    if (Math.abs(d - el.radius) < 8) return el;
                }
            }
            return null;
        }

        bindEvents() {
            this.cvs.addEventListener('mousedown', (e) => {
                if (e.button !== 0) return;
                const mouse = this.getMouse(e);
                
                // åªå¸é™„çœŸæ­£çš„ç‚¹
                const snapPoint = this.getSnapPoint(mouse.x, mouse.y);
                const useX = snapPoint ? snapPoint.x : mouse.x;
                const useY = snapPoint ? snapPoint.y : mouse.y;
                const snapMsg = snapPoint ? 'å¸é™„åˆ°ç‚¹' : '';

                const targetElem = this.getElementUnderMouse(useX, useY);

                switch(this.tool) {
                    case 'point':
                        this.elements.push(new Point(useX, useY));
                        this.saveState();
                        this.updateStatus(`${snapMsg} æ·»åŠ ç‚¹`);
                        break;
                        
                    case 'segment':
                    case 'line':
                        if (!this.temp) {
                            const p1 = new Point(useX, useY);
                            this.elements.push(p1);
                            this.temp = { p1: p1, p2: new Point(useX, useY) };
                            this.updateStatus(`${snapMsg} ç¬¬ä¸€ä¸ªç‚¹`);
                        } else {
                            const p2 = new Point(useX, useY);
                            this.elements.push(p2);
                            this.elements.push(new Line(this.temp.p1, p2, this.tool));
                            this.temp = null;
                            this.saveState();
                            this.updateStatus(`${snapMsg} å®Œæˆ${this.tool === 'segment' ? 'çº¿æ®µ' : 'ç›´çº¿'}`);
                        }
                        break;
                        
                    case 'circle':
                        if (!this.temp) {
                            const center = new Point(useX, useY);
                            this.elements.push(center);
                            this.temp = { center: center, radius: 0 };
                            this.updateStatus(`${snapMsg} åœ†å¿ƒï¼Œå†ç‚¹åŠå¾„`);
                        } else {
                            // åŠå¾„ä¹Ÿæ”¯æŒå¸é™„åˆ°ç‚¹
                            const r = this.temp.center.distanceTo({ x: useX, y: useY });
                            if (r > 1) {
                                this.elements.push(new Circle(this.temp.center, r));
                                this.updateStatus(`${snapMsg} åœ†å®Œæˆ (r=${r.toFixed(1)})`);
                            } else {
                                this.updateStatus(`åŠå¾„å¤ªå°ï¼Œå–æ¶ˆ`);
                            }
                            this.temp = null;
                            this.saveState();
                        }
                        break;
                        
                    case 'intersection':
                        if (!this.intersectCache.a) {
                            this.intersectCache.a = targetElem;
                            if (targetElem) {
                                const type = targetElem instanceof Line ? 'çº¿' : 'åœ†';
                                this.updateStatus(`å·²é€‰ç¬¬ä¸€ä¸ª${type}ï¼Œå†é€‰ç¬¬äºŒä¸ª`);
                            } else {
                                this.updateStatus(`è¯·ç‚¹å‡»ä¸€ä¸ªå›¾å½¢`);
                            }
                        } else if (!this.intersectCache.b && targetElem && targetElem !== this.intersectCache.a) {
                            this.intersectCache.b = targetElem;
                            this.computeAndAddIntersection(this.intersectCache.a, this.intersectCache.b);
                            this.intersectCache.a = null;
                            this.intersectCache.b = null;
                        } else {
                            if (!targetElem) {
                                this.intersectCache.a = null;
                                this.updateStatus(`å–æ¶ˆé€‰æ‹©`);
                            }
                        }
                        break;
                }
                
                this.render();
            });

            this.cvs.addEventListener('mousemove', (e) => {
                const mouse = this.getMouse(e);
                
                // åªå¸é™„çœŸæ­£çš„ç‚¹
                this.snapPoint = this.getSnapPoint(mouse.x, mouse.y);
                
                // é¢„è§ˆç”¨åæ ‡
                const previewSnap = this.getSnapPoint(mouse.x, mouse.y);
                const previewX = previewSnap ? previewSnap.x : mouse.x;
                const previewY = previewSnap ? previewSnap.y : mouse.y;

                if (this.temp) {
                    if (this.temp.p2) {
                        this.temp.p2.x = previewX;
                        this.temp.p2.y = previewY;
                    } else if (this.temp.center) {
                        this.temp.radius = this.temp.center.distanceTo({ x: previewX, y: previewY });
                    }
                }
                
                this.render();
            });

            this.cvs.addEventListener('mouseleave', () => {
                this.snapPoint = null;
                this.render();
            });

            document.querySelectorAll('.tool-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    this.tool = btn.dataset.tool;
                    this.temp = null;
                    this.intersectCache = { a: null, b: null };
                    
                    this.updateStatus(`åˆ‡æ¢åˆ° ${toolNames[this.tool] || this.tool}`);
                    this.render();
                });
            });

            document.getElementById('undo-btn').addEventListener('click', () => this.undo());
            document.getElementById('redo-btn').addEventListener('click', () => this.redo());
            document.getElementById('clear-btn').addEventListener('click', () => {
                if (confirm('æ¸…ç©ºï¼Ÿ')) {
                    this.elements = [];
                    this.temp = null;
                    this.intersectCache = { a: null, b: null };
                    this.saveState();
                    this.render();
                    this.updateStatus('å·²æ¸…ç©º');
                }
            });
            document.getElementById('save-btn').addEventListener('click', () => {
                const link = document.createElement('a');
                link.download = `å°ºè§„_${Date.now()}.png`;
                link.href = this.cvs.toDataURL('image/png');
                link.click();
                this.updateStatus('å›¾ç‰‡å·²ä¿å­˜');
            });

            document.addEventListener('keydown', (e) => {
                if (e.ctrlKey && e.key === 'z') {
                    e.preventDefault();
                    this.undo();
                }
                if (e.ctrlKey && e.key === 'y') {
                    e.preventDefault();
                    this.redo();
                }
            });
        }

        computeAndAddIntersection(a, b) {
            if (!a || !b) return;
            let points = [];

            if (a instanceof Line && b instanceof Line) points = this.intersectLineLine(a, b);
            else if (a instanceof Line && b instanceof Circle) points = this.intersectLineCircle(a, b);
            else if (a instanceof Circle && b instanceof Line) points = this.intersectLineCircle(b, a);
            else if (a instanceof Circle && b instanceof Circle) points = this.intersectCircleCircle(a, b);

            let added = 0;
            points.forEach(p => {
                const exists = this.elements.some(el => el instanceof Point && el.distanceTo(p) < 2);
                if (!exists && isFinite(p.x) && isFinite(p.y)) {
                    this.elements.push(new Point(p.x, p.y));
                    added++;
                }
            });

            if (added > 0) {
                this.saveState();
                this.updateStatus(`æ·»åŠ  ${added} ä¸ªäº¤ç‚¹`);
            }
            this.render();
        }

        intersectLineLine(l1, l2) {
            const A = l1.p1, B = l1.p2;
            const C = l2.p1, D = l2.p2;
            const den = (B.x - A.x) * (D.y - C.y) - (B.y - A.y) * (D.x - C.x);
            if (Math.abs(den) < 1e-10) return [];
            const t = ((C.x - A.x) * (D.y - C.y) - (C.y - A.y) * (D.x - C.x)) / den;
            const x = A.x + t * (B.x - A.x);
            const y = A.y + t * (B.y - A.y);
            return [new Point(x, y)];
        }

        intersectLineCircle(L, C) {
            const A = L.p1, B = L.p2;
            const O = C.center, r = C.radius;
            const dx = B.x - A.x, dy = B.y - A.y;
            const fx = A.x - O.x, fy = A.y - O.y;

            const a = dx * dx + dy * dy;
            const b = 2 * (fx * dx + fy * dy);
            const c = fx * fx + fy * fy - r * r;
            const disc = b * b - 4 * a * c;
            if (disc < -1e-12) return [];
            if (Math.abs(a) < 1e-12) return [];

            const sqrtDisc = Math.sqrt(Math.max(0, disc));
            const t1 = (-b - sqrtDisc) / (2 * a);
            const t2 = (-b + sqrtDisc) / (2 * a);

            const p1 = new Point(A.x + t1 * dx, A.y + t1 * dy);
            const p2 = new Point(A.x + t2 * dx, A.y + t2 * dy);
            return [p1, p2];
        }

        intersectCircleCircle(C1, C2) {
            const O1 = C1.center, O2 = C2.center;
            const r1 = C1.radius, r2 = C2.radius;
            const dx = O2.x - O1.x, dy = O2.y - O1.y;
            const d = Math.hypot(dx, dy);
            if (d > r1 + r2 || d < Math.abs(r1 - r2) || d < 1e-10) return [];

            const a = (r1 * r1 - r2 * r2 + d * d) / (2 * d);
            const h2 = r1 * r1 - a * a;
            if (h2 < -1e-10) return [];
            const h = Math.sqrt(Math.max(0, h2));

            const xm = O1.x + a * dx / d;
            const ym = O1.y + a * dy / d;

            const rx = -dy * h / d;
            const ry = dx * h / d;
            return [
                new Point(xm + rx, ym + ry),
                new Point(xm - rx, ym - ry)
            ];
        }

        render() {
            this.ctx.clearRect(0, 0, this.cvs.width, this.cvs.height);

            // æš—è‰²ç½‘æ ¼
            this.ctx.beginPath();
            this.ctx.strokeStyle = '#2a323c';
            this.ctx.lineWidth = 0.5;
            for (let i = 0; i < this.cvs.width; i += 30) {
                this.ctx.moveTo(i, 0);
                this.ctx.lineTo(i, this.cvs.height);
            }
            for (let i = 0; i < this.cvs.height; i += 30) {
                this.ctx.moveTo(0, i);
                this.ctx.lineTo(this.cvs.width, i);
            }
            this.ctx.stroke();

            // ç»˜åˆ¶æ‰€æœ‰å…ƒç´ 
            this.elements.forEach(el => el.draw(this.ctx));

            // ç»˜åˆ¶å¸é™„æç¤ºï¼ˆåªå¯¹çœŸæ­£çš„ç‚¹ï¼‰
            if (this.snapPoint) {
                this.ctx.beginPath();
                this.ctx.arc(this.snapPoint.x, this.snapPoint.y, 12, 0, 2*Math.PI);
                this.ctx.strokeStyle = '#ffd966';
                this.ctx.lineWidth = 3;
                this.ctx.setLineDash([5, 3]);
                this.ctx.stroke();
                
                // å†…åœˆ
                this.ctx.beginPath();
                this.ctx.arc(this.snapPoint.x, this.snapPoint.y, 5, 0, 2*Math.PI);
                this.ctx.strokeStyle = '#ffd966';
                this.ctx.lineWidth = 2;
                this.ctx.setLineDash([]);
                this.ctx.stroke();
                
                this.ctx.setLineDash([]);
            }

            // ä¸´æ—¶é¢„è§ˆ
            if (this.temp) {
                this.ctx.beginPath();
                this.ctx.strokeStyle = '#ffd966';
                this.ctx.lineWidth = 2.5;
                this.ctx.setLineDash([8, 5]);
                
                if (this.temp.p1 && this.temp.p2) {
                    this.ctx.moveTo(this.temp.p1.x, this.temp.p1.y);
                    this.ctx.lineTo(this.temp.p2.x, this.temp.p2.y);
                    this.ctx.stroke();
                } else if (this.temp.center && this.temp.radius > 0) {
                    this.ctx.arc(this.temp.center.x, this.temp.center.y, this.temp.radius, 0, 2*Math.PI);
                    this.ctx.stroke();
                }
                this.ctx.setLineDash([]);
            }

            // äº¤ç‚¹é€‰æ‹©æç¤º
            if (this.tool === 'intersection' && this.intersectCache.a) {
                this.ctx.beginPath();
                this.ctx.strokeStyle = '#ff8a7a';
                this.ctx.lineWidth = 4;
                this.ctx.setLineDash([8, 4]);
                
                const a = this.intersectCache.a;
                if (a instanceof Line) {
                    this.ctx.moveTo(a.p1.x, a.p1.y);
                    this.ctx.lineTo(a.p2.x, a.p2.y);
                } else if (a instanceof Circle) {
                    this.ctx.arc(a.center.x, a.center.y, a.radius, 0, 2*Math.PI);
                }
                this.ctx.stroke();
                this.ctx.setLineDash([]);
            }
        }
    }

    window.addEventListener('DOMContentLoaded', () => {
        new GeometryCanvas('canvas');
    });
})();
</script>
</body>
</html>
