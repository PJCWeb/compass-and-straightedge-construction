<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å°ºè§„ä½œå›¾å·¥å…·</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Segoe UI', Roboto, Arial, sans-serif;
            background-color: #1a1e24;
            color: #e0e0e0;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }
        .header {
            background-color: #252b33;
            padding: 16px 24px;
            border-radius: 16px;
            box-shadow: 0 6px 12px rgba(0,0,0,0.2);
            margin-bottom: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            border: 1px solid #3a4350;
        }
        .header h1 {
            font-size: 1.8rem;
            font-weight: 600;
            color: #ffd966;
            letter-spacing: 0.5px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        .header-controls {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        .header-controls button {
            padding: 8px 18px;
            background-color: #3a4a5c;
            color: white;
            border: none;
            border-radius: 40px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 500;
            transition: all 0.2s;
            border: 1px solid #4f637a;
        }
        .header-controls button:hover {
            background-color: #4f637a;
            transform: translateY(-1px);
        }
        .main-content {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        .toolbar {
            background-color: #252b33;
            padding: 20px 12px;
            border-radius: 16px;
            box-shadow: 0 6px 12px rgba(0,0,0,0.2);
            min-width: 170px;
            border: 1px solid #3a4350;
            height: fit-content;
        }
        .toolbar h3 {
            margin-bottom: 16px;
            color: #ffd966;
            font-weight: 600;
            font-size: 1.2rem;
            padding-left: 8px;
        }
        .tool-btn {
            display: block;
            width: 100%;
            padding: 10px 14px;
            margin-bottom: 8px;
            background-color: #2e3740;
            border: 1px solid #44515f;
            border-radius: 30px;
            cursor: pointer;
            font-size: 0.95rem;
            text-align: left;
            font-weight: 500;
            color: #d0d9e5;
            transition: all 0.1s;
        }
        .tool-btn:hover {
            background-color: #3f4b58;
            border-color: #ffd966;
            color: white;
        }
        .tool-btn.active {
            background-color: #ffd966;
            color: #1a1e24;
            border-color: #ffd966;
            font-weight: 600;
        }
        .angle-modal {
            display: none;
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0,0,0,0.6);
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        .angle-modal.active {
            display: flex;
        }
        .modal-content {
            background-color: #2e3740;
            padding: 28px 32px;
            border-radius: 36px;
            border: 2px solid #ffd966;
            box-shadow: 0 20px 30px rgba(0,0,0,0.5);
            text-align: center;
            min-width: 280px;
        }
        .modal-content h2 {
            color: #ffd966;
            margin-bottom: 24px;
            font-weight: 500;
        }
        .angle-options {
            display: flex;
            gap: 16px;
            justify-content: center;
            margin-bottom: 24px;
        }
        .angle-option {
            background: #1e242b;
            border: 2px solid #44515f;
            color: white;
            font-size: 1.5rem;
            font-weight: bold;
            width: 70px;
            height: 70px;
            border-radius: 40px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .angle-option:hover {
            background-color: #ffd966;
            border-color: #ffd966;
            color: #1a1e24;
            transform: scale(1.05);
        }
        .modal-close {
            background: #3a4a5c;
            border: none;
            color: white;
            padding: 8px 25px;
            border-radius: 40px;
            font-size: 1rem;
            cursor: pointer;
            border: 1px solid #5f758b;
        }
        .modal-close:hover {
            background-color: #4f637a;
        }
        .canvas-container {
            flex: 1;
            background-color: #252b33;
            padding: 16px;
            border-radius: 16px;
            box-shadow: 0 6px 12px rgba(0,0,0,0.2);
            display: flex;
            flex-direction: column;
            border: 1px solid #3a4350;
            min-width: 500px;
        }
        .canvas-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            padding: 0 8px;
            flex-wrap: wrap;
            gap: 10px;
        }
        .canvas-header label {
            color: #ffd966;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .canvas-header input[type="range"] {
            width: 140px;
            cursor: pointer;
            background: #3a4a5c;
            height: 6px;
            border-radius: 10px;
            accent-color: #ffd966;
        }
        .canvas-header span {
            background: #1e242b;
            padding: 4px 12px;
            border-radius: 30px;
            font-family: monospace;
            border: 1px solid #44515f;
        }
        .canvas-wrapper {
            position: relative;
            width: 100%;
            height: 600px;
            overflow: hidden;
            border-radius: 12px;
            background-color: #1e242b;
            border: 1px solid #44515f;
            cursor: grab;
        }
        .canvas-wrapper.pan-active {
            cursor: grabbing;
        }
        #canvas {
            display: block;
            width: 100%;
            height: 100%;
            background-color: #1e242b;
            image-rendering: crisp-edges;
        }
        .footer {
            background-color: #252b33;
            padding: 14px 24px;
            border-radius: 40px;
            box-shadow: 0 6px 12px rgba(0,0,0,0.2);
            display: flex;
            justify-content: center;
            align-items: center;
            border: 1px solid #3a4350;
        }
        .status-bar {
            padding: 6px 18px;
            background-color: #1e242b;
            border-radius: 30px;
            font-size: 0.95rem;
            font-weight: 500;
            color: #ffd966;
            border: 1px solid #44515f;
            font-family: monospace;
            text-align: center;
        }
        .coords {
            margin-left: 15px;
            color: #a0b8cc;
            font-size: 0.9rem;
        }
    </style>
</head>
<body>
<div class="container">
    <header class="header">
        <h1>ğŸ“ å°ºè§„ä½œå›¾å·¥å…·</h1>
        <div class="header-controls">
            <button id="undo-btn">â†© æ’¤é”€</button>
            <button id="redo-btn">â†ª é‡åš</button>
            <button id="clear-btn">ğŸ—‘ æ¸…ç©º</button>
            <button id="save-btn">ğŸ’¾ ä¿å­˜PNG</button>
            <button id="reset-view-btn">âŸ² é‡ç½®è§†å›¾</button>
        </div>
    </header>
    <div class="main-content">
        <div class="toolbar">
            <h3>âš’ï¸ å·¥å…·</h3>
            <button class="tool-btn" data-tool="point">âš« ç‚¹</button>
            <button class="tool-btn" data-tool="segment">ğŸ“ çº¿æ®µ</button>
            <button class="tool-btn" data-tool="line">ğŸ“ˆ ç›´çº¿</button>
            <button class="tool-btn" data-tool="circle">â­• åœ†</button>
            <button class="tool-btn" data-tool="intersection">âœ– äº¤ç‚¹</button>
            <button class="tool-btn" data-tool="pan">ğŸ–ï¸ ç§»åŠ¨è§†å›¾</button>
            <button class="tool-btn" data-tool="delete">ğŸ—‘ï¸ åˆ é™¤</button>
            <button class="tool-btn" data-tool="angle">ğŸ“ ç‰¹æ®Šè§’åº¦</button>
        </div>
        <div class="canvas-container">
            <div class="canvas-header">
                <label>
                    ğŸ” ç¼©æ”¾ <input type="range" id="zoomRange" min="0.2" max="3.0" step="0.05" value="1.0">
                </label>
                <span id="zoomValue">1.00x</span>
                <span class="coords" id="mouseCoords">ğŸ“Œ 0, 0</span>
            </div>
            <div class="canvas-wrapper" id="canvasWrapper">
                <canvas id="canvas" width="1200" height="800"></canvas>
            </div>
        </div>
    </div>
    <footer class="footer">
        <div id="status" class="status-bar">ğŸ‘‰ é€‰å·¥å…·å¼€å§‹</div>
    </footer>
</div>

<div id="angleModal" class="angle-modal">
    <div class="modal-content">
        <h2>é€‰æ‹©ç‰¹æ®Šè§’åº¦</h2>
        <div class="angle-options">
            <button class="angle-option" data-angle="30">30Â°</button>
            <button class="angle-option" data-angle="45">45Â°</button>
            <button class="angle-option" data-angle="60">60Â°</button>
        </div>
        <button class="modal-close" id="closeAngleModal">å–æ¶ˆ</button>
    </div>
</div>

<script>
(function() {
    const statusEl = document.getElementById('status');
    
    const toolNames = {
        'point': 'ç‚¹',
        'segment': 'çº¿æ®µ',
        'line': 'ç›´çº¿',
        'circle': 'åœ†',
        'intersection': 'äº¤ç‚¹',
        'pan': 'ç§»åŠ¨è§†å›¾',
        'delete': 'åˆ é™¤',
        'angle': 'ç‰¹æ®Šè§’åº¦'
    };

    class Point {
        constructor(x, y, id) {
            this.x = x;
            this.y = y;
            this.id = id || `p_${Date.now()}_${Math.random().toString(36).slice(2,9)}`;
        }
        draw(ctx, transform) {
            let { x, y } = transform.apply(this.x, this.y);
            ctx.beginPath();
            ctx.arc(x, y, 5, 0, 2*Math.PI);
            ctx.fillStyle = '#ffd966';
            ctx.fill();
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 1.5;
            ctx.stroke();
        }
        distanceTo(p) {
            return Math.hypot(this.x - p.x, this.y - p.y);
        }
        isNear(x, y, tol = 8) {
            return this.distanceTo({x, y}) < tol;
        }
    }

    class Line {
        constructor(p1, p2, type = 'segment', id) {
            this.p1 = p1;
            this.p2 = p2;
            this.type = type;
            this.id = id || `l_${Date.now()}_${Math.random().toString(36).slice(2,9)}`;
        }
        draw(ctx, transform) {
            let p1 = transform.apply(this.p1.x, this.p1.y);
            let p2 = transform.apply(this.p2.x, this.p2.y);
            ctx.beginPath();
            if (this.type === 'segment') {
                ctx.moveTo(p1.x, p1.y);
                ctx.lineTo(p2.x, p2.y);
            } else {
                const dx = p2.x - p1.x;
                const dy = p2.y - p1.y;
                const len = Math.hypot(dx, dy);
                if (len < 1e-9) return;
                
                const canvasSize = 2000;
                const ux = dx / len;
                const uy = dy / len;
                
                ctx.moveTo(p1.x - ux * canvasSize, p1.y - uy * canvasSize);
                ctx.lineTo(p1.x + ux * canvasSize, p1.y + uy * canvasSize);
            }
            ctx.strokeStyle = '#7a8b9f';
            ctx.lineWidth = 2.2;
            ctx.stroke();
        }
        
        getNearestPointOnLine(x, y) {
            const A = this.p1, B = this.p2;
            const ax = x - A.x, ay = y - A.y;
            const bx = B.x - A.x, by = B.y - A.y;
            const len2 = bx * bx + by * by;
            if (len2 < 1e-12) return { x: A.x, y: A.y };
            let t = (ax * bx + ay * by) / len2;
            if (this.type === 'segment') {
                t = Math.max(0, Math.min(1, t));
            }
            return {
                x: A.x + t * bx,
                y: A.y + t * by
            };
        }
    }

    class Circle {
        constructor(center, radius, id) {
            this.center = center;
            this.radius = radius;
            this.id = id || `c_${Date.now()}_${Math.random().toString(36).slice(2,9)}`;
        }
        draw(ctx, transform) {
            let center = transform.apply(this.center.x, this.center.y);
            let rPoint = transform.apply(this.center.x + this.radius, this.center.y);
            let transformedR = Math.hypot(rPoint.x - center.x, rPoint.y - center.y);
            
            ctx.beginPath();
            ctx.arc(center.x, center.y, transformedR, 0, 2*Math.PI);
            ctx.strokeStyle = '#7a8b9f';
            ctx.lineWidth = 2.2;
            ctx.stroke();
        }
        
        getNearestPointOnCircle(x, y) {
            const dx = x - this.center.x;
            const dy = y - this.center.y;
            const dist = Math.hypot(dx, dy);
            if (dist < 1e-12) return { x: this.center.x + this.radius, y: this.center.y };
            const scale = this.radius / dist;
            return {
                x: this.center.x + dx * scale,
                y: this.center.y + dy * scale
            };
        }
    }

    class ViewTransform {
        constructor() {
            this.scale = 1.0;
            this.offsetX = 0;
            this.offsetY = 0;
        }
        apply(x, y) {
            return {
                x: x * this.scale + this.offsetX,
                y: y * this.scale + this.offsetY
            };
        }
        inverse(canvasX, canvasY) {
            return {
                x: (canvasX - this.offsetX) / this.scale,
                y: (canvasY - this.offsetY) / this.scale
            };
        }
        reset() {
            this.scale = 1.0;
            this.offsetX = 0;
            this.offsetY = 0;
        }
    }

    class GeometryCanvas {
        constructor(canvasId) {
            this.cvs = document.getElementById(canvasId);
            this.ctx = this.cvs.getContext('2d');
            this.wrapper = document.getElementById('canvasWrapper');
            this.elements = [];
            this.tool = 'point';
            this.temp = null;
            this.stack = [];
            this.redoStack = [];
            this.snapTol = 15;
            this.snapPoint = null;
            this.hoverElement = null;
            this.intersectCache = { a: null, b: null };
            
            this.angleToolState = null;
            this.selectedAngle = null;
            this.angleBaseLine = null;
            
            this.view = new ViewTransform();
            
            this.isPanning = false;
            this.lastPanPoint = { x: 0, y: 0 };
            
            this.zoomRange = document.getElementById('zoomRange');
            this.zoomSpan = document.getElementById('zoomValue');
            
            this.pixelRatio = window.devicePixelRatio || 1;
            
            this.init();
        }

        init() {
            this.bindEvents();
            
            const p1 = new Point(-200, 0);
            const p2 = new Point(200, 0);
            this.elements.push(p1, p2, new Line(p1, p2, 'line'));
            
            this.saveInitialState();
            this.render();
            this.updateStatus('é€‰å·¥å…·å¼€å§‹');
            
            window.addEventListener('resize', () => {
                this.render();
            });
        }

        updateStatus(msg) {
            statusEl.textContent = `ğŸ‘‰ ${msg}`;
        }

        getMouseCanvas(e) {
            const rect = this.cvs.getBoundingClientRect();
            const scaleX = this.cvs.width / rect.width;
            const scaleY = this.cvs.height / rect.height;
            
            return {
                x: (e.clientX - rect.left) * scaleX,
                y: (e.clientY - rect.top) * scaleY
            };
        }

        getMouseLogical(e) {
            const canvasPt = this.getMouseCanvas(e);
            return this.view.inverse(canvasPt.x, canvasPt.y);
        }

        getNearestExistingPoint(x, y) {
            let bestDist = this.snapTol;
            let bestPoint = null;
            
            for (let el of this.elements) {
                if (el instanceof Point) {
                    const d = Math.hypot(el.x - x, el.y - y);
                    if (d < bestDist) {
                        bestDist = d;
                        bestPoint = el;
                    }
                }
            }
            return bestPoint;
        }
        getSnapPointForPointTool(x, y) {
            let bestDist = this.snapTol;
            let bestPoint = null;
            
            for (let el of this.elements) {
                if (el instanceof Point) {
                    const d = Math.hypot(el.x - x, el.y - y);
                    if (d < bestDist) {
                        bestDist = d;
                        bestPoint = { x: el.x, y: el.y };
                    }
                } else if (el instanceof Line) {
                    const p = el.getNearestPointOnLine(x, y);
                    const d = Math.hypot(p.x - x, p.y - y);
                    if (d < bestDist) {
                        bestDist = d;
                        bestPoint = p;
                    }
                } else if (el instanceof Circle) {
                    const p = el.getNearestPointOnCircle(x, y);
                    const d = Math.hypot(p.x - x, p.y - y);
                    if (d < bestDist) {
                        bestDist = d;
                        bestPoint = p;
                    }
                }
            }
            return bestPoint;
        }
        getHoverElement(x, y) {
            for (let i = this.elements.length - 1; i >= 0; i--) {
                const el = this.elements[i];
                if (el instanceof Point && el.isNear(x, y, 8)) return el;
                if (el instanceof Line) {
                    const A = el.p1, B = el.p2;
                    const ax = x - A.x, ay = y - A.y;
                    const bx = B.x - A.x, by = B.y - A.y;
                    const len2 = bx * bx + by * by;
                    if (len2 < 1e-12) continue;
                    let t = (ax * bx + ay * by) / len2;
                    if (el.type === 'segment') t = Math.max(0, Math.min(1, t));
                    const projX = A.x + t * bx;
                    const projY = A.y + t * by;
                    if (Math.hypot(projX - x, projY - y) < 8) return el;
                }
                if (el instanceof Circle) {
                    const d = Math.hypot(x - el.center.x, y - el.center.y);
                    if (Math.abs(d - el.radius) < 8) return el;
                }
            }
            return null;
        }

        saveState() {
            const state = this.elements.map(el => {
                if (el instanceof Point) {
                    return { type: 'Point', x: el.x, y: el.y, id: el.id };
                } else if (el instanceof Line) {
                    return {
                        type: 'Line',
                        p1id: el.p1.id,
                        p2id: el.p2.id,
                        lineType: el.type,
                        id: el.id
                    };
                } else if (el instanceof Circle) {
                    return { type: 'Circle', centerid: el.center.id, radius: el.radius, id: el.id };
                }
                return null;
            }).filter(Boolean);
            this.stack.push(JSON.parse(JSON.stringify(state)));
            this.redoStack = [];
            if (this.stack.length > 40) this.stack.shift();
        }

        saveInitialState() {
            this.saveState();
        }

        undo() {
            if (this.stack.length < 2) return;
            this.redoStack.push(this.stack.pop());
            this.loadState(this.stack[this.stack.length - 1]);
            this.updateStatus('æ’¤é”€');
        }

        redo() {
            if (this.redoStack.length === 0) return;
            const state = this.redoStack.pop();
            this.stack.push(state);
            this.loadState(state);
            this.updateStatus('é‡åš');
        }

        loadState(state) {
            const pointMap = new Map();
            this.elements = [];
            state.forEach(item => {
                if (item.type === 'Point') {
                    const p = new Point(item.x, item.y, item.id);
                    pointMap.set(p.id, p);
                    this.elements.push(p);
                }
            });
            state.forEach(item => {
                if (item.type === 'Line') {
                    const p1 = pointMap.get(item.p1id);
                    const p2 = pointMap.get(item.p2id);
                    if (p1 && p2) {
                        this.elements.push(new Line(p1, p2, item.lineType, item.id));
                    }
                } else if (item.type === 'Circle') {
                    const center = pointMap.get(item.centerid);
                    if (center) {
                        this.elements.push(new Circle(center, item.radius, item.id));
                    }
                }
            });
            this.temp = null;
            this.intersectCache = { a: null, b: null };
            this.angleToolState = null;
            this.selectedAngle = null;
            this.angleBaseLine = null;
            this.render();
        }

        updateZoomDisplay() {
            this.zoomSpan.textContent = this.view.scale.toFixed(2) + 'x';
            this.zoomRange.value = this.view.scale;
        }

        bindEvents() {
            document.querySelectorAll('.tool-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    this.tool = btn.dataset.tool;
                    this.temp = null;
                    this.intersectCache = { a: null, b: null };
                    this.hoverElement = null;
                    
                    if (this.tool === 'angle') {
                        this.angleToolState = 'selecting';
                        this.selectedAngle = null;
                        this.angleBaseLine = null;
                        this.showAngleModal();
                        this.updateStatus('è¯·é€‰æ‹©è§’åº¦');
                    } else {
                        this.angleToolState = null;
                        this.selectedAngle = null;
                        this.angleBaseLine = null;
                        this.updateStatus(`åˆ‡æ¢åˆ° ${toolNames[this.tool] || this.tool}`);
                    }
                    this.render();
                });
            });

            const modal = document.getElementById('angleModal');
            const closeBtn = document.getElementById('closeAngleModal');
            const angleOpts = document.querySelectorAll('.angle-option');

            angleOpts.forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const angle = parseInt(e.target.dataset.angle, 10);
                    this.selectedAngle = angle;
                    modal.classList.remove('active');
                    this.updateStatus(`å·²é€‰ ${angle}Â°ï¼Œè¯·ç‚¹å‡»ä¸€æ¡ç›´çº¿`);
                });
            });

            closeBtn.addEventListener('click', () => {
                modal.classList.remove('active');
                this.tool = 'point';
                this.angleToolState = null;
                this.selectedAngle = null;
                document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
                document.querySelector('[data-tool="point"]').classList.add('active');
                this.updateStatus('å·²å–æ¶ˆï¼Œåˆ‡æ¢åˆ°ç‚¹å·¥å…·');
            });

            this.zoomRange.addEventListener('input', (e) => {
                this.view.scale = parseFloat(e.target.value);
                this.updateZoomDisplay();
                this.render();
            });

            document.getElementById('reset-view-btn').addEventListener('click', () => {
                this.view.reset();
                this.updateZoomDisplay();
                this.render();
                this.updateStatus('è§†å›¾é‡ç½®');
            });

            this.cvs.addEventListener('mousemove', (e) => {
                const logical = this.getMouseLogical(e);
                document.getElementById('mouseCoords').innerHTML = `ğŸ“Œ ${logical.x.toFixed(1)}, ${logical.y.toFixed(1)}`;

                if (this.tool === 'point') {
                    this.snapPoint = this.getSnapPointForPointTool(logical.x, logical.y);
                    this.hoverElement = null;
                } else if (this.tool === 'circle' || this.tool === 'segment' || this.tool === 'line') {
                    const existingPoint = this.getNearestExistingPoint(logical.x, logical.y);
                    if (existingPoint) {
                        this.snapPoint = { x: existingPoint.x, y: existingPoint.y, element: existingPoint };
                    } else {
                        this.snapPoint = null;
                    }
                    this.hoverElement = null;
                } else {
                    this.snapPoint = null;
                    this.hoverElement = this.getHoverElement(logical.x, logical.y);
                }

                const snapLogical = this.snapPoint ? { x: this.snapPoint.x, y: this.snapPoint.y } : logical;

                if (this.isPanning && this.tool === 'pan') {
                    const canvasPt = this.getMouseCanvas(e);
                    const dx = canvasPt.x - this.lastPanPoint.x;
                    const dy = canvasPt.y - this.lastPanPoint.y;
                    this.view.offsetX += dx;
                    this.view.offsetY += dy;
                    this.lastPanPoint = canvasPt;
                    this.render();
                } else if (this.temp && this.tool !== 'delete' && this.tool !== 'pan' && this.tool !== 'angle') {
                    if (this.temp.p2) {
                        this.temp.p2.x = snapLogical.x;
                        this.temp.p2.y = snapLogical.y;
                    } else if (this.temp.center) {
                        this.temp.radius = this.temp.center.distanceTo({ x: snapLogical.x, y: snapLogical.y });
                    }
                    this.render();
                } else {
                    this.render();
                }
            });

            this.cvs.addEventListener('mouseleave', () => {
                this.snapPoint = null;
                this.hoverElement = null;
                this.render();
            });

            this.cvs.addEventListener('mousedown', (e) => {
                if (e.button !== 0) return;
                
                const logical = this.getMouseLogical(e);
                const canvasPt = this.getMouseCanvas(e);
                if (this.tool === 'angle' && this.selectedAngle) {
                    const target = this.getHoverElement(logical.x, logical.y);
                    if (target && target instanceof Line) {
                        this.constructAngleLine(target, this.selectedAngle);
                        this.selectedAngle = null;
                        this.angleToolState = null;
                        this.tool = 'point';
                        document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
                        document.querySelector('[data-tool="point"]').classList.add('active');
                        this.updateStatus('è§’åº¦ç›´çº¿å·²æ·»åŠ ï¼Œè¿”å›ç‚¹å·¥å…·');
                    } else {
                        this.updateStatus('è¯·ç‚¹å‡»ä¸€æ¡ç›´çº¿');
                    }
                    this.render();
                    return;
                }
                if (this.tool === 'pan') {
                    this.isPanning = true;
                    this.lastPanPoint = canvasPt;
                    this.wrapper.classList.add('pan-active');
                    e.preventDefault();
                    return;
                }
                if (this.tool === 'delete') {
                    const target = this.getHoverElement(logical.x, logical.y);
                    if (target) {
                        const index = this.elements.indexOf(target);
                        if (index !== -1) {
                            this.elements.splice(index, 1);
                            this.saveState();
                            this.updateStatus(`å·²åˆ é™¤`);
                        }
                    }
                    this.render();
                    return;
                }
                if (this.tool === 'intersection') {
                    const target = this.getHoverElement(logical.x, logical.y);
                    if (!this.intersectCache.a) {
                        this.intersectCache.a = target;
                        if (target) {
                            const type = target instanceof Line ? 'çº¿' : 'åœ†';
                            this.updateStatus(`å·²é€‰ç¬¬ä¸€ä¸ª${type}ï¼Œå†é€‰ç¬¬äºŒä¸ª`);
                        } else {
                            this.updateStatus(`è¯·ç‚¹å‡»ä¸€ä¸ªå›¾å½¢`);
                        }
                    } else if (!this.intersectCache.b && target && target !== this.intersectCache.a) {
                        this.intersectCache.b = target;
                        this.computeAndAddIntersection(this.intersectCache.a, this.intersectCache.b);
                        this.intersectCache.a = null;
                        this.intersectCache.b = null;
                    } else {
                        if (!target) {
                            this.intersectCache.a = null;
                            this.updateStatus(`å–æ¶ˆé€‰æ‹©`);
                        }
                    }
                    this.render();
                    return;
                }

                switch(this.tool) {
                    case 'point':
                        const pointSnap = this.getSnapPointForPointTool(logical.x, logical.y);
                        if (pointSnap) {
                            this.elements.push(new Point(pointSnap.x, pointSnap.y));
                            this.updateStatus('å¸é™„åˆ°å›¾å½¢ æ·»åŠ ç‚¹');
                        } else {
                            this.elements.push(new Point(logical.x, logical.y));
                            this.updateStatus('æ·»åŠ ç‚¹');
                        }
                        this.saveState();
                        break;
                        
                    case 'segment':
                    case 'line':
                        if (!this.temp) {
                            const p1 = this.getNearestExistingPoint(logical.x, logical.y);
                            if (p1) {
                                this.temp = { p1: p1, p2: new Point(logical.x, logical.y) };
                                this.updateStatus('ä½¿ç”¨ç°æœ‰ç‚¹ä½œä¸ºç¬¬ä¸€ä¸ªç‚¹ï¼Œå†ç‚¹å‡»ç°æœ‰ç‚¹å®Œæˆ');
                            } else {
                                this.updateStatus('è¯·ç‚¹å‡»ä¸€ä¸ªç°æœ‰ç‚¹ä½œä¸ºç¬¬ä¸€ä¸ªç‚¹');
                            }
                        } else {
                            const p2 = this.getNearestExistingPoint(logical.x, logical.y);
                            if (p2) {
                                this.elements.push(new Line(this.temp.p1, p2, this.tool));
                                this.temp = null;
                                this.saveState();
                                this.updateStatus('çº¿æ®µ/ç›´çº¿å®Œæˆ');
                            } else {
                                this.updateStatus('è¯·ç‚¹å‡»ä¸€ä¸ªç°æœ‰ç‚¹ä½œä¸ºç¬¬äºŒä¸ªç‚¹');
                            }
                        }
                        break;
                        
                    case 'circle':
                        if (!this.temp) {
                            const centerPoint = this.getNearestExistingPoint(logical.x, logical.y);
                            if (centerPoint) {
                                this.temp = { center: centerPoint, radius: 0 };
                                this.updateStatus('ä½¿ç”¨ç°æœ‰ç‚¹ä½œä¸ºåœ†å¿ƒï¼Œå†ç‚¹å‡»ç°æœ‰ç‚¹ç¡®å®šåŠå¾„');
                            } else {
                                this.updateStatus('è¯·ç‚¹å‡»ä¸€ä¸ªç°æœ‰ç‚¹ä½œä¸ºåœ†å¿ƒ');
                            }
                        } else {
                         
                            const radiusPoint = this.getNearestExistingPoint(logical.x, logical.y);
                            if (radiusPoint) {
                                const r = this.temp.center.distanceTo(radiusPoint);
                                if (r > 1) {
                                    this.elements.push(new Circle(this.temp.center, r));
                                    this.updateStatus(`åœ†å®Œæˆ (åŠå¾„: ${r.toFixed(1)})`);
                                } else {
                                    this.updateStatus(`åŠå¾„å¤ªå°ï¼Œå–æ¶ˆ`);
                                }
                                this.temp = null;
                                this.saveState();
                            } else {
                                this.updateStatus('è¯·ç‚¹å‡»ä¸€ä¸ªç°æœ‰ç‚¹ä½œä¸ºåŠå¾„ç‚¹');
                            }
                        }
                        break;
                }

                this.render();
            });

            window.addEventListener('mouseup', (e) => {
                if (this.isPanning) {
                    this.isPanning = false;
                    this.wrapper.classList.remove('pan-active');
                    this.render();
                }
            });

            document.getElementById('undo-btn').addEventListener('click', () => this.undo());
            document.getElementById('redo-btn').addEventListener('click', () => this.redo());
            document.getElementById('clear-btn').addEventListener('click', () => {
                if (confirm('æ¸…ç©ºæ‰€æœ‰å›¾å½¢ï¼Ÿ')) {
                    this.elements = [];
                    this.temp = null;
                    this.intersectCache = { a: null, b: null };
                    this.angleToolState = null;
                    this.selectedAngle = null;
                    this.angleBaseLine = null;
                    this.saveState();
                    this.render();
                    this.updateStatus('å·²æ¸…ç©º');
                }
            });
            document.getElementById('save-btn').addEventListener('click', () => {
                const link = document.createElement('a');
                link.download = `å°ºè§„_${Date.now()}.png`;
                link.href = this.cvs.toDataURL('image/png');
                link.click();
                this.updateStatus('å›¾ç‰‡å·²ä¿å­˜');
            });

            document.addEventListener('keydown', (e) => {
                if (e.ctrlKey && e.key === 'z') {
                    e.preventDefault();
                    this.undo();
                }
                if (e.ctrlKey && e.key === 'y') {
                    e.preventDefault();
                    this.redo();
                }
            });
        }

        showAngleModal() {
            const modal = document.getElementById('angleModal');
            modal.classList.add('active');
        }

        constructAngleLine(baseLine, angleDeg) {
            const center = baseLine.p1;
            const dx = baseLine.p2.x - baseLine.p1.x;
            const dy = baseLine.p2.y - baseLine.p1.y;
            
            const baseAngle = Math.atan2(dy, dx);
            const rad = angleDeg * Math.PI / 180;
            
            const newAngle = baseAngle + rad;
            const length = 150; 
            const newDx = Math.cos(newAngle) * length;
            const newDy = Math.sin(newAngle) * length;
            
            const newX = center.x + newDx;
            const newY = center.y + newDy;
            
            const farPoint = new Point(newX, newY);
            this.elements.push(farPoint);
            const newLine = new Line(center, farPoint, 'line');
            this.elements.push(newLine);
            
            this.saveState();
            this.updateStatus(`å·²åˆ›å»º ${angleDeg}Â° è§’ç›´çº¿`);
        }

        computeAndAddIntersection(a, b) {
            if (!a || !b) return;
            let points = [];

            if (a instanceof Line && b instanceof Line) points = this.intersectLineLine(a, b);
            else if (a instanceof Line && b instanceof Circle) points = this.intersectLineCircle(a, b);
            else if (a instanceof Circle && b instanceof Line) points = this.intersectLineCircle(b, a);
            else if (a instanceof Circle && b instanceof Circle) points = this.intersectCircleCircle(a, b);

            let added = 0;
            points.forEach(p => {
                const exists = this.elements.some(el => el instanceof Point && el.distanceTo(p) < 2);
                if (!exists && isFinite(p.x) && isFinite(p.y)) {
                    this.elements.push(new Point(p.x, p.y));
                    added++;
                }
            });

            if (added > 0) {
                this.saveState();
                this.updateStatus(`æ·»åŠ  ${added} ä¸ªäº¤ç‚¹`);
            }
            this.render();
        }

        intersectLineLine(l1, l2) {
            const A = l1.p1, B = l1.p2;
            const C = l2.p1, D = l2.p2;
            const den = (B.x - A.x) * (D.y - C.y) - (B.y - A.y) * (D.x - C.x);
            if (Math.abs(den) < 1e-10) return [];
            const t = ((C.x - A.x) * (D.y - C.y) - (C.y - A.y) * (D.x - C.x)) / den;
            const x = A.x + t * (B.x - A.x);
            const y = A.y + t * (B.y - A.y);
            return [new Point(x, y)];
        }

        intersectLineCircle(L, C) {
            const A = L.p1, B = L.p2;
            const O = C.center, r = C.radius;
            const dx = B.x - A.x, dy = B.y - A.y;
            const fx = A.x - O.x, fy = A.y - O.y;

            const a = dx * dx + dy * dy;
            const b = 2 * (fx * dx + fy * dy);
            const c = fx * fx + fy * fy - r * r;
            const disc = b * b - 4 * a * c;
            if (disc < -1e-12) return [];
            if (Math.abs(a) < 1e-12) return [];

            const sqrtDisc = Math.sqrt(Math.max(0, disc));
            const t1 = (-b - sqrtDisc) / (2 * a);
            const t2 = (-b + sqrtDisc) / (2 * a);

            const p1 = new Point(A.x + t1 * dx, A.y + t1 * dy);
            const p2 = new Point(A.x + t2 * dx, A.y + t2 * dy);
            return [p1, p2];
        }

        intersectCircleCircle(C1, C2) {
            const O1 = C1.center, O2 = C2.center;
            const r1 = C1.radius, r2 = C2.radius;
            const dx = O2.x - O1.x, dy = O2.y - O1.y;
            const d = Math.hypot(dx, dy);
            if (d > r1 + r2 || d < Math.abs(r1 - r2) || d < 1e-10) return [];

            const a = (r1 * r1 - r2 * r2 + d * d) / (2 * d);
            const h2 = r1 * r1 - a * a;
            if (h2 < -1e-10) return [];
            const h = Math.sqrt(Math.max(0, h2));

            const xm = O1.x + a * dx / d;
            const ym = O1.y + a * dy / d;

            const rx = -dy * h / d;
            const ry = dx * h / d;
            return [
                new Point(xm + rx, ym + ry),
                new Point(xm - rx, ym - ry)
            ];
        }

        render() {
            const rect = this.cvs.getBoundingClientRect();
            const displayWidth = rect.width;
            const displayHeight = rect.height;
            
            if (this.cvs.width !== displayWidth || this.cvs.height !== displayHeight) {
                this.cvs.width = displayWidth;
                this.cvs.height = displayHeight;
            }

            this.ctx.clearRect(0, 0, this.cvs.width, this.cvs.height);
            this.ctx.save();

            this.ctx.beginPath();
            this.ctx.strokeStyle = '#2a323c';
            this.ctx.lineWidth = 0.5;

            const topLeft = this.view.inverse(0, 0);
            const bottomRight = this.view.inverse(this.cvs.width, this.cvs.height);
            
            const step = 30;
            const startX = Math.floor(topLeft.x / step) * step;
            const startY = Math.floor(topLeft.y / step) * step;

            for (let x = startX; x <= bottomRight.x; x += step) {
                let canvasP1 = this.view.apply(x, topLeft.y);
                let canvasP2 = this.view.apply(x, bottomRight.y);
                this.ctx.moveTo(canvasP1.x, canvasP1.y);
                this.ctx.lineTo(canvasP2.x, canvasP2.y);
            }
            for (let y = startY; y <= bottomRight.y; y += step) {
                let canvasP1 = this.view.apply(topLeft.x, y);
                let canvasP2 = this.view.apply(bottomRight.x, y);
                this.ctx.moveTo(canvasP1.x, canvasP1.y);
                this.ctx.lineTo(canvasP2.x, canvasP2.y);
            }
            this.ctx.stroke();

            this.elements.forEach(el => el.draw(this.ctx, this.view));

            if (this.tool === 'point' && this.snapPoint) {
                let sp = this.view.apply(this.snapPoint.x, this.snapPoint.y);
                this.ctx.beginPath();
                this.ctx.arc(sp.x, sp.y, 12, 0, 2*Math.PI);
                this.ctx.strokeStyle = '#ffd966';
                this.ctx.lineWidth = 3;
                this.ctx.setLineDash([5, 3]);
                this.ctx.stroke();
                
                this.ctx.beginPath();
                this.ctx.arc(sp.x, sp.y, 5, 0, 2*Math.PI);
                this.ctx.strokeStyle = '#ffd966';
                this.ctx.lineWidth = 2;
                this.ctx.setLineDash([]);
                this.ctx.stroke();
                this.ctx.setLineDash([]);
            }
            if ((this.tool === 'circle' || this.tool === 'segment' || this.tool === 'line') && this.snapPoint) {
                let sp = this.view.apply(this.snapPoint.x, this.snapPoint.y);
                this.ctx.beginPath();
                this.ctx.arc(sp.x, sp.y, 12, 0, 2*Math.PI);
                this.ctx.strokeStyle = '#ffd966';
                this.ctx.lineWidth = 3;
                this.ctx.setLineDash([5, 3]);
                this.ctx.stroke();
                
                this.ctx.beginPath();
                this.ctx.arc(sp.x, sp.y, 5, 0, 2*Math.PI);
                this.ctx.strokeStyle = '#ffd966';
                this.ctx.lineWidth = 2;
                this.ctx.setLineDash([]);
                this.ctx.stroke();
                this.ctx.setLineDash([]);
            }
            if (this.tool !== 'point' && this.tool !== 'circle' && this.tool !== 'segment' && this.tool !== 'line' && this.tool !== 'pan' && this.hoverElement) {
                if (this.hoverElement instanceof Point) {
                    let sp = this.view.apply(this.hoverElement.x, this.hoverElement.y);
                    this.ctx.beginPath();
                    this.ctx.arc(sp.x, sp.y, 12, 0, 2*Math.PI);
                    this.ctx.strokeStyle = '#ffd966';
                    this.ctx.lineWidth = 3;
                    this.ctx.setLineDash([5, 3]);
                    this.ctx.stroke();
                    
                    this.ctx.beginPath();
                    this.ctx.arc(sp.x, sp.y, 5, 0, 2*Math.PI);
                    this.ctx.strokeStyle = '#ffd966';
                    this.ctx.lineWidth = 2;
                    this.ctx.setLineDash([]);
                    this.ctx.stroke();
                    this.ctx.setLineDash([]);
                } else if (this.hoverElement instanceof Line) {
                    let p1 = this.view.apply(this.hoverElement.p1.x, this.hoverElement.p1.y);
                    let p2 = this.view.apply(this.hoverElement.p2.x, this.hoverElement.p2.y);
                    this.ctx.beginPath();
                    if (this.hoverElement.type === 'segment') {
                        this.ctx.moveTo(p1.x, p1.y);
                        this.ctx.lineTo(p2.x, p2.y);
                    } else {
                        const dx = p2.x - p1.x;
                        const dy = p2.y - p1.y;
                        const len = Math.hypot(dx, dy);
                        if (len > 1e-9) {
                            const ux = dx / len;
                            const uy = dy / len;
                            const canvasSize = 2000;
                            this.ctx.moveTo(p1.x - ux * canvasSize, p1.y - uy * canvasSize);
                            this.ctx.lineTo(p1.x + ux * canvasSize, p1.y + uy * canvasSize);
                        }
                    }
                    this.ctx.strokeStyle = '#ffd966';
                    this.ctx.lineWidth = 4;
                    this.ctx.setLineDash([5, 3]);
                    this.ctx.stroke();
                    this.ctx.setLineDash([]);
                } else if (this.hoverElement instanceof Circle) {
                    let center = this.view.apply(this.hoverElement.center.x, this.hoverElement.center.y);
                    let rPoint = this.view.apply(this.hoverElement.center.x + this.hoverElement.radius, this.hoverElement.center.y);
                    let rad = Math.hypot(rPoint.x - center.x, rPoint.y - center.y);
                    this.ctx.beginPath();
                    this.ctx.arc(center.x, center.y, rad, 0, 2*Math.PI);
                    this.ctx.strokeStyle = '#ffd966';
                    this.ctx.lineWidth = 4;
                    this.ctx.setLineDash([5, 3]);
                    this.ctx.stroke();
                    this.ctx.setLineDash([]);
                }
            }

           
            if (this.temp && this.tool !== 'delete' && this.tool !== 'pan' && this.tool !== 'angle') {
                this.ctx.beginPath();
                this.ctx.strokeStyle = '#ffd966';
                this.ctx.lineWidth = 2.5;
                this.ctx.setLineDash([8, 5]);
                
                if (this.temp.p1 && this.temp.p2) {
                    let p1c = this.view.apply(this.temp.p1.x, this.temp.p1.y);
                    let p2c = this.view.apply(this.temp.p2.x, this.temp.p2.y);
                    this.ctx.moveTo(p1c.x, p1c.y);
                    this.ctx.lineTo(p2c.x, p2c.y);
                    this.ctx.stroke();
                } else if (this.temp.center && this.temp.radius > 0) {
                    let center = this.view.apply(this.temp.center.x, this.temp.center.y);
                    let rPoint = this.view.apply(this.temp.center.x + this.temp.radius, this.temp.center.y);
                    let rad = Math.hypot(rPoint.x - center.x, rPoint.y - center.y);
                    this.ctx.arc(center.x, center.y, rad, 0, 2*Math.PI);
                    this.ctx.stroke();
                }
                this.ctx.setLineDash([]);
            }

            if (this.tool === 'intersection' && this.intersectCache.a) {
                this.ctx.beginPath();
                this.ctx.strokeStyle = '#ff8a7a';
                this.ctx.lineWidth = 4;
                this.ctx.setLineDash([8, 4]);
                
                const a = this.intersectCache.a;
                if (a instanceof Line) {
                    let p1c = this.view.apply(a.p1.x, a.p1.y);
                    let p2c = this.view.apply(a.p2.x, a.p2.y);
                    this.ctx.moveTo(p1c.x, p1c.y);
                    this.ctx.lineTo(p2c.x, p2c.y);
                } else if (a instanceof Circle) {
                    let center = this.view.apply(a.center.x, a.center.y);
                    let rPoint = this.view.apply(a.center.x + a.radius, a.center.y);
                    let rad = Math.hypot(rPoint.x - center.x, rPoint.y - center.y);
                    this.ctx.arc(center.x, center.y, rad, 0, 2*Math.PI);
                }
                this.ctx.stroke();
                this.ctx.setLineDash([]);
            }

            this.ctx.restore();
        }
    }

    window.addEventListener('DOMContentLoaded', () => {
        new GeometryCanvas('canvas');
    });
})();
</script>
</body>
</html>
